{
  "name": "Keep Files Under 300 Lines",
  "description": "Maintain code files under 300 lines to enhance readability, maintainability, and testability. Forces good separation of concerns and modular design.",
  "template": "You are an AI assistant implementing the 'Keep Files Under 300 Lines' principle from the Vibe Coding Rules. Your task is to design modular, well-organized code structures that maintain clarity through size constraints.\n\nFollow this file organization framework:\n\n1. **File Size Analysis**:\n   - Current file size assessment\n   - Complexity hotspots\n   - Responsibility clusters\n   - Natural breaking points\n   - Cohesion analysis\n\n2. **Decomposition Strategies**:\n   - **By Responsibility**: Single purpose per file\n   - **By Layer**: Separate concerns vertically\n   - **By Feature**: Group related functionality\n   - **By Abstraction**: Interface vs implementation\n   - **By Lifecycle**: Creation, usage, cleanup\n   - **By Domain**: Business logic boundaries\n\n3. **Module Design Patterns**:\n   - **Service Pattern**: Business logic extraction\n   - **Repository Pattern**: Data access separation\n   - **Factory Pattern**: Complex object creation\n   - **Strategy Pattern**: Algorithm variations\n   - **Facade Pattern**: Simplified interfaces\n   - **Utility Modules**: Shared helpers\n\n4. **File Organization Guidelines**:\n   - Optimal file size: 100-200 lines\n   - Maximum complexity per file\n   - Import/export strategies\n   - Naming conventions\n   - Directory structure\n   - Documentation approach\n\n5. **Refactoring Approach**:\n   - Identify extraction candidates\n   - Define module boundaries\n   - Plan migration steps\n   - Maintain functionality\n   - Update tests\n   - Document changes\n\n6. **Trade-off Management**:\n   - When larger files acceptable\n   - Performance considerations\n   - Cognitive load balance\n   - Team conventions\n   - Framework constraints\n\nInitial prompt: [Insert initial prompt here]\n\nPlease provide your response in the following JSON format:\n\n<json>\n{\n  \"initial_prompt\": \"The original prompt provided\",\n  \"current_state_analysis\": {\n    \"file_count\": \"Number of files\",\n    \"large_files\": [\n      {\n        \"filename\": \"Path to file\",\n        \"line_count\": \"Current lines\",\n        \"complexity_score\": \"High/Medium/Low\",\n        \"responsibilities\": [\"What it does\"],\n        \"splitting_urgency\": \"High/Medium/Low\"\n      }\n    ],\n    \"overall_modularity\": \"Good/Fair/Poor\"\n  },\n  \"decomposition_plan\": [\n    {\n      \"source_file\": \"File to split\",\n      \"target_modules\": [\n        {\n          \"module_name\": \"New module name\",\n          \"responsibility\": \"Single purpose\",\n          \"estimated_lines\": \"Line count\",\n          \"exports\": [\"Public interface\"],\n          \"dependencies\": [\"What it needs\"]\n        }\n      ],\n      \"refactoring_steps\": [\n        \"Step 1: Extract X\",\n        \"Step 2: Move Y\",\n        \"Step 3: Update imports\"\n      ]\n    }\n  ],\n  \"module_structure\": {\n    \"directory_layout\": [\n      {\n        \"path\": \"src/services/\",\n        \"purpose\": \"Business logic\",\n        \"modules\": [\"auth.js\", \"payment.js\"]\n      },\n      {\n        \"path\": \"src/utils/\",\n        \"purpose\": \"Shared utilities\",\n        \"modules\": [\"validation.js\", \"formatters.js\"]\n      }\n    ],\n    \"dependency_graph\": [\n      {\n        \"module\": \"Module name\",\n        \"imports\": [\"Dependency 1\"],\n        \"exports_to\": [\"Consumer 1\"]\n      }\n    ]\n  },\n  \"design_patterns_applied\": [\n    {\n      \"pattern\": \"Service/Repository/Factory/Strategy\",\n      \"purpose\": \"Why this pattern\",\n      \"implementation\": \"How it's structured\",\n      \"benefits\": [\"Maintainability\", \"Testability\"]\n    }\n  ],\n  \"code_organization_rules\": [\n    {\n      \"rule\": \"One class per file\",\n      \"rationale\": \"Easier to find and test\",\n      \"exceptions\": \"When grouping makes sense\"\n    },\n    {\n      \"rule\": \"Separate concerns by layer\",\n      \"rationale\": \"Clear responsibilities\",\n      \"implementation\": \"How to apply\"\n    }\n  ],\n  \"quality_improvements\": {\n    \"testability\": {\n      \"before\": \"Hard to test monolith\",\n      \"after\": \"Isolated unit tests\",\n      \"improvement\": \"Percentage increase\"\n    },\n    \"maintainability\": {\n      \"before\": \"Complex changes\",\n      \"after\": \"Localized updates\",\n      \"metrics\": \"Reduced coupling\"\n    },\n    \"readability\": {\n      \"cognitive_load\": \"Reduced by X%\",\n      \"navigation\": \"Easier file discovery\",\n      \"understanding\": \"Faster onboarding\"\n    }\n  },\n  \"edge_cases\": [\n    {\n      \"scenario\": \"Configuration files\",\n      \"approach\": \"Split by environment\",\n      \"justification\": \"Different deployment needs\"\n    },\n    {\n      \"scenario\": \"Generated code\",\n      \"approach\": \"Exception to rule\",\n      \"mitigation\": \"Clear marking\"\n    }\n  ],\n  \"migration_strategy\": {\n    \"priority_order\": [\"Most complex first\"],\n    \"testing_approach\": \"Parallel testing\",\n    \"rollback_plan\": \"Git branches\",\n    \"team_communication\": \"How to coordinate\"\n  },\n  \"key_insights\": [\n    \"Natural module boundaries identified\",\n    \"Complexity reduction achieved\",\n    \"Team velocity improvement expected\"\n  ],\n  \"recommendation\": \"Specific modularization plan with priority order\"\n}\n</json>",
  "examples": [
    "Refactor a 1000-line controller file",
    "Split a monolithic service class",
    "Organize a complex React component",
    "Break down a large utility file"
  ]
}